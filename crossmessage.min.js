/*!
 * crossmessage.js  ·  Cross-Domain Window Reliable Message Delivery
 * @Author: 刘希航 <liu.xihang@zte.com.cn>
 * @Date: 2025-10-01 15:00:00
 * @Description: Enterprise-grade cross-domain window communication library with reliable message delivery guarantee
 */
!function(e,n){"function"==typeof define&&define.amd?define([],n):"object"==typeof module&&module.exports?module.exports=n():e.CrossMessage=n()}("undefined"!=typeof self?self:this,function(){"use strict";const e="CROSSPOST_MSG",n="CROSSPOST_ACK",r=new Map,t=new Map;function o(){return Math.random().toString(36).slice(2)}function s(e){if("undefined"==typeof window)return{safe:!0};const n=window.location.protocol,r=e.split(":")[0]+":";return"https:"===n&&"http:"===r?{safe:!1,reason:"HTTPS页面不能向HTTP页面发送postMessage（混合内容安全策略）。解决方案：将目标页面升级为HTTPS，或在HTTP环境下使用此库"}:{safe:!0}}function i(e,n,r,t,o,s,i){try{e.postMessage({type:r,key:t,payload:o,expectAck:s,id:i},n)}catch(e){}}function c(c,a,d){if(r.has(c))return Promise.reject(new Error(`[CrossMessage] key="${c}" 的发送任务已存在`));const{interval:u=1e3,timeout:f=5e3,targetWindow:w,targetOrigin:l="*"}=d||{},p=w||"undefined"!=typeof window&&(window.opener||window.parent||window);if(!p)return Promise.reject(new Error("[CrossMessage] 未能解析 targetWindow"));if("*"!==l){const e=s(l);if(!e.safe)return Promise.reject(new Error(`[CrossMessage] ${e.reason}`))}return new Promise((s,d)=>{let w,g,y=!0;function m(){clearInterval(w),clearTimeout(g),window.removeEventListener("message",v),r.delete(c),t.delete(c),y=!1}function v(e){const r=e.data;y&&r&&r.type===n&&r.key===c&&e.source===p&&("*"!==l&&e.origin!==l||(s({key:c}),m()))}window.addEventListener("message",v),g=setTimeout(()=>{m(),d(new Error(`[CrossMessage] key="${c}" 等待回执超时（${f}ms）`))},f),w=setInterval(()=>{if(function(e){try{return e&&e.closed}catch(e){return!1}}(p))return m(),void d(new Error(`[CrossMessage] key="${c}" 目标窗口已关闭`));i(p,l,e,c,a,!0,o())},u),i(p,l,e,c,a,!0,o()),r.set(c,{stop:m,resolve:s,reject:d})})}return{sendUntilAck:c,receiveOnce:function(o,s){if(t.has(o))return t.get(o).promise;const{allowedOrigins:i=["*"],expectedSourceWindow:c}=s||{};let a,d;const u=new Promise((e,n)=>{a=e,d=n});return t.set(o,{promise:u,resolve:a,reject:d,received:!1}),window.addEventListener("message",function s(a){const d=a.data;if(!d||d.type!==e||d.key!==o)return;if(c&&a.source!==c)return;if(!(i.includes("*")||i.includes(a.origin)))return;const u=t.get(o);if(u&&!u.received){u.received=!0,u.resolve(d.payload);try{a.source&&"function"==typeof a.source.postMessage&&a.source.postMessage({type:n,key:o,payload:void 0,expectAck:!1,id:d.id},a.origin||"*")}catch(e){}window.removeEventListener("message",s),t.delete(o),r.delete(o)}}),u},openAndSend:function(e,n,r,t){const{windowFeatures:o,...i}=t||{},a="string"==typeof e?e.trim():e;if(!a)return Promise.reject(new Error("[CrossMessage] URL 不能为空"));let d=function(e){try{return new URL(e).origin}catch(n){try{if("undefined"!=typeof window&&window.location)return new URL(e,window.location.href).origin}catch(e){}return null}}(a);if(d||(console.warn(`[CrossMessage] 无法从 URL "${a}" 提取 origin，回退到 '*'`),d="*"),"*"!==d){const e=s(d);if(!e.safe)return Promise.reject(new Error(`[CrossMessage] ${e.reason}`))}const u=window.open(a,"_blank",o);if(!u){const e="[CrossMessage] 无法打开目标窗口，可能的原因：\n  1. 浏览器弹窗拦截器阻止了窗口打开\n  2. 当前调用不在用户交互事件中（如点击事件）\n  3. 浏览器达到窗口数量限制\n  建议：在用户点击等交互事件中调用此函数";return Promise.reject(new Error(e))}return c(n,r,{...i,targetWindow:u,targetOrigin:d})}}});