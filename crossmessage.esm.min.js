/*!
 * crossmessage.esm.js  ·  跨域窗口可靠消息投递 (ES Module)
 * @Author: 刘希航 <mateboy@foxmail.com>
 * @Date: 2025-10-01 10:29:56
 * @Description: 跨域窗口可靠消息投递，兼容：ES Module
 *  发送方：sendUntilAck(key, payload, opts)  -> Promise
 *    成功：resolve({key})   失败：reject(Error('超时'))
 *  接收方：receiveOnce(key)  -> Promise<payload>
 *  便捷API：openAndSend(url, key, payload, opts)  -> Promise
 */
const MSG_TYPE="CROSSPOST_MSG",ACK_TYPE="CROSSPOST_ACK",senders=new Map,receivers=new Map;function uid(){return Math.random().toString(36).slice(2)}function extractOrigin(e){try{return new URL(e).origin}catch(n){try{if("undefined"!=typeof window&&window.location)return new URL(e,window.location.href).origin}catch(e){}return null}}function checkMixedContent(e){if("undefined"==typeof window)return{safe:!0};const n=window.location.protocol,r=e.split(":")[0]+":";return"https:"===n&&"http:"===r?{safe:!1,reason:"HTTPS页面不能向HTTP页面发送postMessage（混合内容安全策略）。解决方案：将目标页面升级为HTTPS，或在HTTP环境下使用此库"}:{safe:!0}}function isWindowClosed(e){try{return e&&e.closed}catch(e){return!1}}function post(e,n,r,t,s,o,i){try{e.postMessage({type:r,key:t,payload:s,expectAck:o,id:i},n)}catch(e){}}function sendUntilAck(e,n,r){if(senders.has(e))return Promise.reject(new Error(`[CrossMessage] key="${e}" 的发送任务已存在`));const{interval:t=1e3,timeout:s=5e3,targetWindow:o,targetOrigin:i="*"}=r||{},c=o||"undefined"!=typeof window&&(window.opener||window.parent||window);if(!c)return Promise.reject(new Error("[CrossMessage] 未能解析 targetWindow"));if("*"!==i){const e=checkMixedContent(i);if(!e.safe)return Promise.reject(new Error(`[CrossMessage] ${e.reason}`))}return new Promise((r,o)=>{let d,a,u=!0;function w(){clearInterval(d),clearTimeout(a),window.removeEventListener("message",f),senders.delete(e),receivers.delete(e),u=!1}function f(n){const t=n.data;u&&t&&t.type===ACK_TYPE&&t.key===e&&n.source===c&&("*"!==i&&n.origin!==i||(r({key:e}),w()))}window.addEventListener("message",f),a=setTimeout(()=>{w(),o(new Error(`[CrossMessage] key="${e}" 等待回执超时（${s}ms）`))},s),d=setInterval(()=>{if(isWindowClosed(c))return w(),void o(new Error(`[CrossMessage] key="${e}" 目标窗口已关闭`));post(c,i,MSG_TYPE,e,n,!0,uid())},t),post(c,i,MSG_TYPE,e,n,!0,uid()),senders.set(e,{stop:w,resolve:r,reject:o})})}function receiveOnce(e,n){if(receivers.has(e))return receivers.get(e).promise;const{allowedOrigins:r=["*"],expectedSourceWindow:t}=n||{};let s,o;const i=new Promise((e,n)=>{s=e,o=n});return receivers.set(e,{promise:i,resolve:s,reject:o,received:!1}),window.addEventListener("message",function n(s){const o=s.data;if(!o||o.type!==MSG_TYPE||o.key!==e)return;if(t&&s.source!==t)return;if(!(r.includes("*")||r.includes(s.origin)))return;const i=receivers.get(e);if(i&&!i.received){i.received=!0,i.resolve(o.payload);try{s.source&&"function"==typeof s.source.postMessage&&s.source.postMessage({type:ACK_TYPE,key:e,payload:void 0,expectAck:!1,id:o.id},s.origin||"*")}catch(e){}window.removeEventListener("message",n),receivers.delete(e),senders.delete(e)}}),i}function openAndSend(e,n,r,t){const{windowFeatures:s,...o}=t||{},i="string"==typeof e?e.trim():e;if(!i)return Promise.reject(new Error("[CrossMessage] URL 不能为空"));let c=extractOrigin(i);if(c||(console.warn(`[CrossMessage] 无法从 URL "${i}" 提取 origin，回退到 '*'`),c="*"),"*"!==c){const e=checkMixedContent(c);if(!e.safe)return Promise.reject(new Error(`[CrossMessage] ${e.reason}`))}const d=window.open(i,"_blank",s);if(!d){const e="[CrossMessage] 无法打开目标窗口，可能的原因：\n1. 浏览器弹窗拦截器阻止了窗口打开\n2. 当前调用不在用户交互事件中（如点击事件）\n3. 浏览器达到窗口数量限制\n建议：在用户点击等交互事件中调用此函数";return Promise.reject(new Error(e))}return sendUntilAck(n,r,{...o,targetWindow:d,targetOrigin:c})}export{sendUntilAck,receiveOnce,openAndSend};export default{sendUntilAck:sendUntilAck,receiveOnce:receiveOnce,openAndSend:openAndSend};