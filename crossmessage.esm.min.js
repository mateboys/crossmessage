/*!
 * crossmessage.esm.js  ·  跨域窗口可靠消息投递 (ES Module)
 * @Author: 刘希航 <mateboy@foxmail.com>
 * @Date: 2025-10-01 20:00:00
 * @Description: 跨域窗口可靠消息投递，兼容：ES Module
 *  发送方：sendUntilAck(key, payload, opts)  -> Promise
 *    成功：resolve({key})   失败：reject(Error('超时'))
 *  接收方：receiveOnce(key)  -> Promise<payload>
 *  便捷API：openAndSend(url, key, payload, opts)  -> Promise
 */
/* -------------------- 常量 -------------------- */
const MSG_TYPE="CROSSMESSAGE_MSG",ACK_TYPE="CROSSMESSAGE_ACK",senders=new Map,receivers=new Map;// key -> { promise, resolve, reject, received }
/* -------------------- 工具 -------------------- */
function uid(){return Math.random().toString(36).slice(2)}
// 从 URL 中提取 origin（协议+域名+端口）
function extractOrigin(e){try{
// 尝试直接解析（适用于完整 URL）
return new URL(e).origin}catch(n){
// 如果失败，尝试使用当前页面作为 base URL（适用于相对路径）
try{if("undefined"!=typeof window&&window.location)return new URL(e,window.location.href).origin}catch(e){
// 如果还是失败，返回 null
}return null}}
// 检查混合内容安全问题
function checkMixedContent(e){if("undefined"==typeof window)return{safe:!0};const n=window.location.protocol,r=e.split(":")[0]+":";
// HTTPS -> HTTP 会被阻止
return"https:"===n&&"http:"===r?{safe:!1,reason:"HTTPS页面不能向HTTP页面发送postMessage（混合内容安全策略）。解决方案：将目标页面升级为HTTPS，或在HTTP环境下使用此库"}:{safe:!0}}
// 检查目标窗口是否已关闭
function isWindowClosed(e){try{return e&&e.closed}catch(e){
// 跨域访问 closed 属性可能抛异常，假设窗口存在
return!1}}
/* -------------------- 消息封装 -------------------- */function post(e,n,r,t,o,i,s){try{e.postMessage({type:r,key:t,payload:o,expectAck:i,id:s},n)}catch(e){
// 忽略 targetWindow 暂不可用导致的异常
}}
/* ===================================================
 * 发送方 API：sendUntilAck
 *  opts: { interval=1000, timeout=5000 }
 *  成功：resolve({key})   失败：reject(Error)
 * =================================================== */function sendUntilAck(e,n,r){if(senders.has(e))return Promise.reject(new Error(`[CrossMessage] key="${e}" 的发送任务已存在`));const{interval:t=1e3,timeout:o=5e3,targetWindow:i,targetWindowName:s,targetOrigin:// 新增：可选的目标窗口名称（用于跨标签页）
c="*"}=r||{};
// 智能解析目标窗口
let d=i;if(!d&&"undefined"!=typeof window){
// 1. 优先使用用户显式提供的窗口名称（独立标签页通信）
if("string"==typeof s&&s.trim())try{
// 使用 window.open 的特性：如果窗口存在则返回引用，不存在则创建
const e=window.open("",s.trim());
// 关键检测：如果是刚创建的新窗口，它的 location.href 会是 'about:blank'
// 且没有 opener（因为我们用空 URL 打开的）
if(e&&e!==window)
// 检查是否是刚创建的空白窗口
try{"about:blank"===e.location.href&&""===e.document.title&&!e.document.body?.hasChildNodes()?
// 这是新创建的窗口，说明目标不存在，立即关闭它
e.close():e.closed||(
// 这是已存在的窗口
d=e)}catch(n){
// 跨域情况下无法访问 location，但说明窗口确实存在
e.closed||(d=e)}}catch(e){}
// 2. 尝试父子窗口关系（弹窗/iframe场景）
d||!window.opener&&!window.parent||(d=window.opener||window.parent);
// 3. 若仍未解析，交由调用方显式传入
}if(!d)return Promise.reject(new Error("[CrossMessage] 未能解析 targetWindow。请传入 targetWindow 或 targetWindowName，并确保接收端已设置 window.name。"));
// 检查混合内容安全问题（如果指定了具体的 targetOrigin）
if("*"!==c){const e=checkMixedContent(c);if(!e.safe)return Promise.reject(new Error(`[CrossMessage] ${e.reason}`))}return new Promise((r,i)=>{let s,a,w=!0;function u(){clearInterval(s),clearTimeout(a),window.removeEventListener("message",l),senders.delete(e),
// 内存保护：同时清理可能存在的接收方记录，防止极端场景下的内存泄漏
receivers.delete(e),w=!1}function l(n){const t=n.data;w&&t&&t.type===ACK_TYPE&&t.key===e&&n.source===d&&("*"!==c&&n.origin!==c||(r({key:e}),u()))}window.addEventListener("message",l),a=setTimeout(()=>{u(),i(new Error(`[CrossMessage] key="${e}" 等待回执超时（${o}ms）`))},o),s=setInterval(()=>{
// 检查目标窗口是否已关闭
if(isWindowClosed(d))return u(),void i(new Error(`[CrossMessage] key="${e}" 目标窗口已关闭`));post(d,c,MSG_TYPE,e,n,!0,uid())},t),post(d,c,MSG_TYPE,e,n,!0,uid()),// 立即发一次
senders.set(e,{stop:u,resolve:r,reject:i})})}
/* ===================================================
 * 接收方 API：receiveOnce
 *  返回 Promise<payload>
 * =================================================== */function receiveOnce(e,n){if(receivers.has(e))return receivers.get(e).promise;const{allowedOrigins:r=["*"],expectedSourceWindow:t,name:o}=n||{};
// 可选：为接收端设置窗口名称，便于跨标签页通过名称定位
try{if("undefined"!=typeof window&&null!=o){let e,n=!1;"string"==typeof o?e=o.trim():o&&"object"==typeof o&&("string"==typeof o.value&&(e=o.value.trim()),!0===o.deep&&(n=!0)),e&&(n?window.name=e:window.name?window.name!==e&&console.warn(`[CrossMessage] 当前页已存在 window.name="${window.name}"，未覆盖为 "${e}"。如需强制，请传 { name: { value: "${e}", deep: true } }`):window.name=e)}}catch(e){}let i,s;const c=new Promise((e,n)=>{i=e,s=n});return receivers.set(e,{promise:c,resolve:i,reject:s,received:!1}),window.addEventListener("message",function n(o){const i=o.data;if(!i||i.type!==MSG_TYPE||i.key!==e)return;
// 校验来源窗口
if(t&&o.source!==t)return;
// 校验来源域
if(!(r.includes("*")||r.includes(o.origin)))return;const s=receivers.get(e);if(s&&!s.received){s.received=!0,s.resolve(i.payload);try{
// 使用 ev.source 作为目标窗口，使用 ev.origin 作为回执目标 origin
o.source&&"function"==typeof o.source.postMessage&&o.source.postMessage({type:ACK_TYPE,key:e,payload:void 0,expectAck:!1,id:i.id},o.origin||"*")}catch(e){}window.removeEventListener("message",n),receivers.delete(e),
// 内存保护：同时清理可能存在的发送方记录，防止极端场景下的内存泄漏
senders.delete(e)}}),c}
/* ===================================================
 * 便捷 API：openAndSend
 *  打开窗口并发送消息，自动提取 targetOrigin
 * =================================================== */function openAndSend(e,n,r,t){const{windowFeatures:o,...i}=t||{},s="string"==typeof e?e.trim():e;
// 清理 URL：去除首尾空格
if(!s)return Promise.reject(new Error("[CrossMessage] URL 不能为空"));
// 自动提取 targetOrigin，如果失败则回退到 '*'
let c=extractOrigin(s);
// 检查混合内容安全问题（只有指定了具体 origin 时才检查）
if(c||(console.warn(`[CrossMessage] 无法从 URL "${s}" 提取 origin，回退到 '*'`),c="*"),"*"!==c){const e=checkMixedContent(c);if(!e.safe)return Promise.reject(new Error(`[CrossMessage] ${e.reason}`))}
// 打开窗口（使用清理后的 URL）
const d=window.open(s,"_blank",o);if(!d){
// 提供更详细的错误信息
const e="[CrossMessage] 无法打开目标窗口，可能的原因：\n1. 浏览器弹窗拦截器阻止了窗口打开\n2. 当前调用不在用户交互事件中（如点击事件）\n3. 浏览器达到窗口数量限制\n建议：在用户点击等交互事件中调用此函数";return Promise.reject(new Error(e))}
// 发送消息
return sendUntilAck(n,r,{...i,targetWindow:d,targetOrigin:c})}
/* -------------------- 公开接口 -------------------- */
// ES Module 导出
export{sendUntilAck,receiveOnce,openAndSend};
// 默认导出（包含所有方法的对象）
export default{sendUntilAck:sendUntilAck,receiveOnce:receiveOnce,openAndSend:openAndSend};